Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor Reduction.
Require Import Run.

(* The end-to-end definition of Shor's algorithm, combining the facts from 
   Shor.v and ShorAux.v into a digestable form. *)

(** Coq definitions that will be extracted to OCaml **)

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

   Inputs:
     N = number to factor
     rnds = stream of random real values
     i = index into rnds
     niter = max number of iterations
   
   Output:
     None or Some x where x is a nontrivial factor of N.

   Algorithm: Up to a maximum number of iterations, select "a" uniformly from 
   [1,n-1] and
     1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
     2. Measure the first n qubits, resulting in the n-bit number x.
     3. Run continued fraction expansion (= OF_post) to get r, which is a 
        candidate for the order (ord a N).
     4. Use r to try to factor N.

  The probability of success (returning Some) and the resources (aka qubits and 
  gates) used is a function of N and niter (see proofs below). *)

(* N   : number to factor
   out : outcome from sampling *)
Definition process N out :=
  let n := n N in
  let k := k N in
  let a := fst_join (2^(n + k)) out in
  let x := snd_join (2^(n + k)) out in
  (* try to factor *)
  if Nat.gcd a N =? 1%nat
  then factor a N (OF_post a N (fst_join (2^k) x) n)
  else Some (Nat.gcd a N).

(* N   : number to factor
   rnd : source of randomness for sampling *)
Definition shor_body N rnd :=
  let n := n N in
  let k := k N in
  (* create a distribution corresponding to choosing an 'a' and running
     Shor's circuit with this value 
     NOTE: technically, we don't need to run the circuit in the case where a is not
     coprime to N, but it's easier to write the code this way -KH *)
  let distr := join (uniform 1 N) 
                    (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
  (* sample from the distribution *)
  let out := sample distr rnd in
  (* try to factor *)
  process N out.

Definition end_to_end_shors N rnds :=
  iterate rnds (shor_body N).

(** Correctness properties for Shor's **)

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

(* Main lemma #1 - the probability that shor_body returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.Shor_correct_full). *)
Lemma shor_body_returns_order : forall (a N : nat),
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  pr_outcome_sum 
      (run (to_base_ucom (n + k) circ))
      (fun x => OF_post a N (fst_join (2^k) x) n =? ord a N) 
    >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N Ha1 Ha2 n0 k0 circ.
  subst n0 k0 circ.
  remember (fun x => OF_post a N x (n N) =? ord a N) as f'.
  replace (fun x : nat => OF_post a N (fst_join (2^k N) x) (n N) =? ord a N) 
    with (fun x : nat => f' (fst_join (2^k N) x)).
  rewrite rewrite_pr_outcome_sum.
  specialize (Shor.Shor_correct a N Ha1 Ha2) as H1.
  specialize (shor_circuit_same' a N) as H2.
  unfold prob_shor_outputs in H2.
  erewrite Rsum_eq.
  2: { intro i. rewrite H2. reflexivity. lia. }
  unfold probability_of_success in H1.
  unfold n in *.
  unfold k in *.
  unfold r_found in H1.
  subst f'.
  apply H1.
  subst f'.
  reflexivity.
Qed.

Definition leads_to_factor N a := 
  nontrivgcd a N ||
  (nontrivgcd (a ^ ((ord a N) / 2)%nat - 1) N ||
   nontrivgcd (a ^ ((ord a N) / 2)%nat + 1) N).

(* Main lemma #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factoring_succeeds : forall N,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
   pr_outcome_sum
     (uniform 1 N)
     (fun x => leads_to_factor N x)
   >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  assert (H :( N - 1 <= 2 * count1 (leads_to_factor N) (N - 1))%nat).
  subst N.
  apply reduction_factor_order_finding; auto.
  assert (2 < N)%nat.
  subst N. 
  rewrite <- (Nat.mul_1_l 2).
  apply Nat.mul_lt_mono_nonneg; try lia.
  apply Nat.pow_gt_1; lia.
  rewrite pr_outcome_sum_count by lia.
  unfold count1 in *. erewrite count_eq.
  2 : { intros x Hx. replace (2 + x - 1)%nat with (x + 1)%nat by lia. reflexivity. }
  rewrite count_eq with (g := leads_to_factor N).
  apply le_INR in H. rewrite mult_INR in H. replace (INR 2) with 2 in H by easy.
  unfold Rdiv.
  assert (0 < INR (N - 1)).
  { apply lt_0_INR. lia. }
  assert (0 < / INR (N - 1)).
  { apply Harmonic.INR_inv_pos. lia. }
  apply Rmult_le_compat_r with (r := (/ INR (N - 1))%R) in H; try lra.
  rewrite Rinv_r in H by lra.
  apply Rmult_le_compat_l with (r := 2%R) in H; try lra.
  intros. f_equal. lia.
Qed.

Definition is_a_factor x y := exists z, (1 < z < y)%nat /\ y = (z * x)%nat.

Lemma gcd_is_factor : forall x y, (1 < Nat.gcd x y < y)%nat -> is_a_factor (Nat.gcd x y) y.
Proof.
  intros x y H.
  unfold is_a_factor.
  specialize (Nat.gcd_divide_r x y) as G. destruct G.
  exists x0.
  split; try lia.
  split; nia.
Qed.

Lemma factor_returns_factor : forall a N r x,
  factor a N r = Some x -> is_a_factor x N.
Proof.
  intros a N r x H.
  unfold factor in H.
  remember (Nat.gcd (a ^ (r / 2) - 1) N) as k1.
  remember (Nat.gcd (a ^ (r / 2) + 1) N) as k2.
  bdestruct (1 <? k1); bdestruct (k1 <? N); 
    bdestruct (1 <? k2); bdestruct (k2 <? N); 
    simpl in H; inversion H; subst;
    apply gcd_is_factor; auto.
Qed.

Lemma end_to_end_shors_correct : forall N rnds x,
    (1 < N)%nat ->
    (Forall (fun x => 0 <= x < 1) rnds) ->
    end_to_end_shors N rnds = Some x ->
    is_a_factor x N.
Proof.
  intros N rnds x H Hrnds H0.
  unfold end_to_end_shors in H0.
  induction rnds as [ | rnd rnds]; intros.
  inversion H0.
  simpl in H0.
  destruct (shor_body N rnd) eqn:sb; auto.
  inversion H0; subst.
  unfold shor_body, process in sb.
  (* first, some cleanup *)
  remember (join (uniform 1 N)
                 (fun a : nat =>
                    run (to_base_ucom (n N + k N) (shor_circuit a N)))) as distr.
  remember (fst_join (2^(n N + k N)) (sample distr rnd)) as a.
  remember (snd_join (2^(n N + k N)) (sample distr rnd)) as o.
  (* now back to the proof... *)
  bdestruct (Nat.gcd a N =? 1).
  apply factor_returns_factor in sb. 
  auto.
  inversion sb.
  apply gcd_is_factor.
  assert (1 <= a < N)%nat.
  { rewrite Heqa, Heqdistr.
    inversion Hrnds.
    apply fst_join_uniform; try easy.
    intros. apply length_run.
    2: apply pow_positive; lia.
    intros. apply distribution_run.
    apply uc_well_typed_shor_circuit. lia.
  }
  assert (0 < Nat.gcd a N)%nat.
  apply Natgcd_pos; lia.
  assert (Nat.gcd a N <= a)%nat.
  rewrite Nat.gcd_comm.
  apply Misc.Nat_gcd_le_r.
  lia. 
  lia.
  inversion Hrnds. apply IHrnds; assumption.
Qed.

Lemma shor_body_succeeds_with_high_probability' : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    let f1 a := leads_to_factor N a in
    let f2 a x := (OF_post a N (fst_join (2^k) x) n =? ord a N) ||
                  negb (Nat.gcd a N =? 1) in
    pr_outcome_sum distr
      (fun z => let x := fst_join (2^(n + k)) z in
             let y := snd_join (2^(n + k)) z in
             f1 x && f2 x y)
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion H0. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (H1 p O Hp2). simpl in H1. lia. lia.
  }
  assert (ILog : (1 <= Nat.log2 N)%nat).
  { specialize (Nat.log2_pos N) as G. lia.
  }
  specialize (κn4in01 (Nat.log2 N) ILog) as G.
  apply pr_outcome_sum_join_geq.
  apply distribution_uniform.
  apply H1N.
  lra.
  apply shor_factoring_succeeds; auto.
  intros i Hi.
  split.
  apply length_run.
  subst f2.
  assert (Hdist : distribution (run (to_base_ucom (n + k) (shor_circuit i N)))).
  { apply distribution_run.
    apply uc_well_typed_shor_circuit.
    rewrite length_uniform in Hi.
    lia.
    lia.
  }
  bdestruct (Nat.gcd i N =? 1).
  eapply Rge_trans.
  apply Rle_ge.
  apply pr_outcome_sum_orb.
  destruct Hdist as [Hdist _]; auto.
  apply shor_body_returns_order.
  split.
  destruct i. simpl in H2. lia. lia.
  rewrite length_uniform in Hi. lia. lia.
  unfold coprime.
  assumption.
  rewrite pr_outcome_sum_true.
  destruct Hdist as [_ Hdist].
  rewrite Hdist.
  lra.
  intros j Hj.
  bdestruct (Nat.gcd i N =? 1).
  easy.
  simpl. rewrite orb_true_r. reflexivity.
Qed.

Lemma shor_body_succeeds_with_high_probability : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    pr_outcome_sum distr (fun x => negb (isNone (process N x)))
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros N HN1 HN2 HN3 n k distr.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion HN2. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (HN3 p O Hp2). simpl in HN3. lia. lia.
  }
  assert (Hdist: distribution distr).
  subst distr. 
  apply distribution_join.
  apply distribution_uniform.
  lia.
  intros i Hi.
  apply distribution_run.
  apply uc_well_typed_shor_circuit.
  rewrite length_uniform in Hi.
  lia.
  lia.
  apply Rle_ge.
  eapply Rle_trans.
  apply Rge_le.
  apply shor_body_succeeds_with_high_probability'; auto.
  apply pr_outcome_sum_implies.
  destruct Hdist as [Hdist _]; auto.
  simpl.
  intros x H.
  unfold process.
  subst n k.
  remember (fst_join (2 ^ (n N + k N)) x) as a.
  remember (snd_join (2 ^ (n N + k N)) x) as y.
  clear - H.
  destruct (Nat.gcd a N =? 1) eqn:E; auto.
  apply beq_nat_true in E.
  apply andb_prop in H as [H1 H2].
  simpl in H2. rewrite orb_false_r in H2.
  apply beq_nat_true in H2. rewrite H2.
  unfold factor.
  unfold leads_to_factor in H1.
  remember (a ^ (ord a N / 2) + 1)%nat as ap1.
  remember (a ^ (ord a N / 2) - 1)%nat as am1.
  replace ((1 <? Nat.gcd am1 N) && (Nat.gcd am1 N <? N)) with (nontrivgcd am1 N) by (unfold nontrivgcd; reflexivity).
  replace ((1 <? Nat.gcd ap1 N) && (Nat.gcd ap1 N <? N)) with (nontrivgcd ap1 N) by (unfold nontrivgcd; reflexivity).
  destruct (nontrivgcd am1 N). easy.
  destruct (nontrivgcd ap1 N). easy.
  simpl in H1. rewrite orb_false_r in H1.
  unfold nontrivgcd, nontriv in H1. rewrite E in H1. simpl in H1. easy.
Qed.

Lemma shor_body_fails_with_low_probability : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    pr_outcome_sum distr (fun x => isNone (process N x))
      <= 1 - (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion H0. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (H1 p O Hp2). simpl in H1. lia. lia.
  }
  rewrite pr_outcome_sum_negb.
  specialize (shor_body_succeeds_with_high_probability N H H0 H1) as G.
  assert (distribution distr).
  { apply distribution_join.
    apply distribution_uniform.
    lia.
    intros.
    apply distribution_run.
    apply uc_well_typed_shor_circuit.
    rewrite length_uniform in H2. lia.
    lia.
  }
  destruct H2. rewrite H3.
  assert (forall r1 r2 r3, r2 >= r3 -> r1 - r2 <= r1 - r3)%R by (intros; lra).
  apply H4. apply G.
Qed.

(* For n iterations of end_to_end_shors, the probability of success is
   1 - (1 - ((1 / 2) * (κ / INR (Nat.log2 N)^4))^n). *)
Local Opaque pow leads_to_factor.
Lemma end_to_end_shors_fails_with_low_probability : forall N niter r,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  pr_Ps (fun rnds => isNone (end_to_end_shors N rnds) = true) niter r ->
  (r <= (1 - (1 / 2) * (κ / INR (Nat.log2 N)^4))^niter)%R.
Proof.
  intros N niter r HN1 HN2 HN3 H.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion HN2. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (HN3 p O Hp2). simpl in HN3. lia. lia.
  }
  unfold end_to_end_shors in H.
  specialize (shor_body_fails_with_low_probability N HN1 HN2 HN3) as Hbody.
  apply pr_outcome_sum_leq_exists in Hbody.
  destruct Hbody as [r0 [? ?]].
  apply pr_iterate_None with (n := niter) in H1.
  eapply pr_Ps_unique in H. 
  2: apply H1.
  subst r.
  remember (1 / 2 * (κ / INR (Nat.log2 N) ^ 4)) as β.
  clear H1.
  apply pow_incr.
  assumption.
  apply distribution_join.
  apply distribution_uniform.
  lia.
  intros i Hi.
  apply distribution_run.
  apply uc_well_typed_shor_circuit.
  rewrite length_uniform in Hi.
  auto.
  lia.
Qed.

